"""
Implementation of a PHYEX timestep
"""
# pylint: disable=no-member

import sys
import os
import importlib.util
import logging
import tempfile
import netCDF4
import numpy
from scipy.interpolate import RegularGridInterpolator
import f90nml
from pppy import PPPY
from . import Phyex1DError
from . import Cst
from . import wasp
from ctypesForFortran import MISSING
import ephem
import datetime

class PhysicsBase(PPPY):
    """
    Implementation of the forcing
    This class is not intended to be used directly
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, prognostic_variables,
                 pyphyex=None, pyecrad=None, namel=None, dx=0, dy=0, attrs=None):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param prognostic_variable: List of prognostic variables
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param pyecrad: path to the pyecrad.py file
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        :param attrs: dictionnary holding caes attributes to override
        """
        super().__init__(dt, method, name, tag, inputfile=inputfile, grid=grid.filename)
        self.inputfile = inputfile
        self.grid = grid
        self.prognostic_variables = prognostic_variables
        self.pyphyex = pyphyex  # file path
        self._pyphyex = None  # module
        self.pyecrad = pyecrad  # file path
        self._pyecrad = None  # module
        self.namel = namel  # provided namelist keys
        self.full_phyex_namel = None  # all PHYEX namelist keys inclunding default values if needed
        self.dx = dx
        self.dy = dy
        if self.namel is not None and not isinstance(namel, dict):
            if self.namel.endswith('.namel') and os.path.exists(self.namel):
                # namelist is a filename provided by the user
                namelist_file = self.namel
            else:
                # look for a namelis with the name provided in the user's directory,
                # then in the package directory
                user_dir = os.path.join(os.environ['HOME'], '.phyex1d', 'namelists')
                package_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'namelists')
                for namel_dir in (user_dir, package_dir):
                    namelist_file = os.path.join(namel_dir, self.namel + '.namel')
                    if os.path.exists(namelist_file):
                        break
            if namelist_file is None:
                raise Phyex1DError('Namelist not found')

            with open(namelist_file, 'r', encoding='UTF-8') as f:
                self.namel = f90nml.read(f)

        class Case():  # pylint: disable=too-few-public-methods
            """Empty class to store case attributes"""
            def __init__(self, inputfile):
                self.adv_ua = 0
                self.adv_va = 0
                with netCDF4.Dataset(inputfile, 'r') as nc:
                    for k in nc.ncattrs():
                        setattr(self, k, getattr(nc, k))
                if attrs is not None:
                    for k, v in attrs.items():
                        setattr(self, k, v)
        self.case = Case(inputfile)
        self.interpolators = {}

        self.cst = Cst()

    def setup(self, init_state, duration):
        """
        :param init_state: intial state
        :param duration: duration of the simulation
        """
        # PHYEX SETUP
        try:
            if self.pyphyex is None:
                # pyphyex.py should be found by python
                import pyphyex  # pylint: disable=import-outside-toplevel
            else:
                # We import pyphyex.py by file path
                spec = importlib.util.spec_from_file_location('pyphyex', self.pyphyex)
                pyphyex = importlib.util.module_from_spec(spec)
                sys.modules['pyphyex'] = pyphyex
                spec.loader.exec_module(pyphyex)
        except ModuleNotFoundError:
            logging.error("The module pyphyex has not been found. " +
                          "This module can be built with the PHYEX package " +
                          "(available on github). Details on the compilation " +
                          "process can be found in the PHYEX documentation.")
            raise
        self._pyphyex = pyphyex

        def set_default(nml):
            """
            Set default values for schemes
            """
            if 'PHYEX' not in nml:
                nml['PHYEX'] = {}
            nml['PHYEX']['CMICRO'] = nml['PHYEX'].get('CMICRO', 'ICE3')
            nml['PHYEX']['CSCONV'] = nml['PHYEX'].get('CSCONV', 'EDKF')
            nml['PHYEX']['CTURB'] = nml['PHYEX'].get('CTURB', 'TKEL')
            nml['PHYEX']['RAD'] = nml['PHYEX'].get('RAD', 'ECRAD')
            nml['PHYEX']['SURFACE'] = nml['PHYEX'].get('SURFACE', 'WASP')

        with tempfile.NamedTemporaryFile() as namel:
            nml = f90nml.read(namel.name)
            if self.namel is not None:
                for k, v in self.namel.items():
                    nml[k] = v
            set_default(nml)
            nml.write(namel.name, force=True)
            # First call to really initialize
            try:
                zdzmin = self.grid.get_altitude('FLUX', init_state, self.prognostic_variables).min()
            except (KeyError, Phyex1DError):
                logging.warning('Unable to compute true minimal thickness, use 20m instead')
                zdzmin = 20.
            numnml = 20
            pyphyex.PYINI_PHYEX('PHX1D', 33, namel.name, False, numnml, 0, 1, self._dt, zdzmin,
                                nml['PHYEX']['CMICRO'], nml['PHYEX']['CSCONV'],
                                nml['PHYEX']['CTURB'],
                                LDCHANGEMODEL=True, LDDEFAULTVAL=True, LDREADNAM=True,
                                LDCHECK=True, KPRINT=0, LDINIT=True)
            os.remove(f'fort.{numnml}')
            # Second call to only write the namelist
            numnml = 21
            pyphyex.PYINI_PHYEX('PHX1D', 33, namel.name, False, numnml, 0, 1, self._dt, zdzmin,
                                nml['PHYEX']['CMICRO'], nml['PHYEX']['CSCONV'],
                                nml['PHYEX']['CTURB'],
                                LDCHANGEMODEL=False, LDDEFAULTVAL=False, LDREADNAM=False,
                                LDCHECK=False, KPRINT=1, LDINIT=False)
            self.full_phyex_namel = f90nml.read(f'fort.{numnml}')
            set_default(self.full_phyex_namel)
            os.remove(f'fort.{numnml}')

        if nml['PHYEX']['RAD'] == 'ECRAD' and self.case.radiation == 'on':
            # ECRAD SETUP
            try:
                if self.pyecrad is None:
                    # pyecrad.py should be found by python
                    import pyecrad  # pylint: disable=import-outside-toplevel
                else:
                    # We import pyecrad.py by file path
                    spec = importlib.util.spec_from_file_location('pyecrad', self.pyecrad)
                    pyecrad = importlib.util.module_from_spec(spec)
                    sys.modules['pyecrad'] = pyecrad
                    spec.loader.exec_module(pyecrad)
            except ModuleNotFoundError:
                logging.error("The module pyecrad has not been found.")
                raise
            self._pyecrad = pyecrad

            with tempfile.NamedTemporaryFile() as namel:
                nml = f90nml.read(namel.name)
                if self.namel is not None:
                    for k, v in self.namel.items():
                        nml[k] = v
                set_default(nml)
                nml.write(namel.name, force=True)
                pyecrad.setup(namel.name)

    def finalize(self):
        """
        Close open resources
        """
        super().finalize()
        self._pyphyex.close()
        if self._pyecrad is not None:
            self._pyecrad.close()

    def execute(self, previous_state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param previous_state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """
        # PHYEX
        new_state = self.phyex(previous_state, timestep, timestep_number)

        # Forcings
        new_state = self.forcing(new_state, timestep, timestep_number)

        # Vertical coordinate
        self.add_vertical_coordinate(new_state)

        # Conversions
        self.add_conversions(new_state)

        return new_state

    def add_vertical_coordinate(self, state):
        """
        Adds the vertical coordinate to the current state
        :param state: current state
        """
        state['Z_mass'] = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        state['P'] = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        state['Z_flux'] = self.grid.get_altitude('FLUX', state, self.prognostic_variables)
        top = -1 if self.grid.ascending else 0
        if numpy.all(state['Z_flux'][top] == numpy.inf):
            state['Z_flux'][top] = state['Z_flux'][-2 if self.grid.ascending else 1]

    def add_conversions(self, state):
        """
        Add some derived variables to the current state
        :param state: current state
        """
        pressure_mass = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        exner = (pressure_mass / 1.E5) ** (self.cst.Rd / self.cst.Cpd)
        if 'T' in self.prognostic_variables:
            state['Theta'] = state['T'] / exner
        elif 'Theta' in self.prognostic_variables:
            state['T'] = state['Theta'] * exner

        if 'qv' in self.prognostic_variables:
            qt = state['qv'].copy()
            for var in ('qc', 'qi', 'qr', 'qs', 'qg', 'qh'):
                qt += state[var]
            state['qt'] = qt
            for v in ('v', 'c', 'i', 'r', 's', 'g', 'h'):
                state['r' + v] = state['q' + v] / (1. - qt)
        elif 'rv' in self.prognostic_variables:
            rt = state['rv'].copy()
            for var in ('rc', 'ri', 'rr', 'rs', 'rg', 'rh'):
                rt += state[var]
            state['rt'] = rt
            for v in ('v', 'c', 'i', 'r', 's', 'g', 'h'):
                state['q' + v] = state['r' + v] / (1. + rt)

    def build_init_state(self, init_state):
        """
        Initial state
        """
        init_state = super().build_init_state(init_state)
        nc_names = {'Theta': 'theta',
                    'T': 'ta',
                    'Zs': 'orog',
                    'Ps': 'ps',
                    'qv': 'qv',
                    'qc': 'ql',
                    'qi': 'qi',
                    'qr': 'qr',
                    'qs': 'qs',
                    'qg': 'qg',
                    'qh': 'qh',
                    'rv': 'rv',
                    'rc': 'rl',
                    'ri': 'ri',
                    'rr': 'rr',
                    'rs': 'rs',
                    'rg': 'rg',
                    'rh': 'rh',
                    'u': 'ua',
                    'v': 'va',
                    'w': 'wa',
                    'sshf': 'hfss',
                    'slhf': 'hfls',
                    'z0': 'z0',
                    'z0h': 'z0h',
                    'z0q': 'z0q',
                    'tke': 'tke',
                    'Tskin': 'tskin',
                    'ustar': 'ustar',
                    'Ts': 'ts',
                    'SolarIrradiance': 'i0',
                    'albedo': 'alb',
                    'emissivity': 'emis',
                    'sza': 'sza',
                    'o3': 'o3',
                    'lat': 'lat',
                    'lon': 'lon'
                  }

        with netCDF4.Dataset(self.inputfile, 'r') as nc:
            # Surface fields
            for var in ('Zs', 'Ps', 'sshf', 'slhf', 'z0', 'z0h', 'z0q', 'Tskin', 'Ts', 'ustar',
                        'SolarIrradiance', 'albedo', 'emissivity', 'sza', 'lat', 'lon'):
                if nc_names[var] in nc.variables:
                    init_state[var] = nc[nc_names[var]][0]
                else:
                    logging.warning('%s not found in the netCDF driver!', nc_names[var])

            # We perform the interpolation on the natural vertical coordinate
            if self.grid.kind in ('H', 'hybridH'):
                input_coord = nc['zh'][0, :] + nc['orog'][0]
                output_coord = self.grid.get_altitude('MASS', init_state, self.prognostic_variables)
            elif self.grid.kind in ('P', 'hybridP'):
                input_coord = nc['pa'][0, :]
                output_coord = self.grid.get_pressure('MASS', init_state, self.prognostic_variables)
            else:
                raise Phyex1DError('Wrong grid kind')

            # Interpolation of initial profiles
            for var in self.prognostic_variables:
                if var in ('qc', 'qi', 'qr', 'qs', 'qg', 'qh',
                           'rc', 'ri', 'rr', 'rs', 'rg', 'rh',
                           'w') and nc_names[var] not in nc.variables:
                    init_state[var] = numpy.zeros(output_coord.shape)
                    logging.warning('%s not found in the netCDF driver!', nc_names[var])
                else:
                    interp = RegularGridInterpolator((input_coord, ), nc[nc_names[var]][0, :],
                                                     bounds_error=False, fill_value=None)
                    init_state[var] = interp(output_coord)
            init_state['tke'] = numpy.maximum(self.full_phyex_namel['NAM_TURBn']['XTKEMIN'],
                                              init_state['tke'])

        # Vertical coordinates
        self.add_vertical_coordinate(init_state)

        # Conversions
        self.add_conversions(init_state)

        # Arrays needed to keep memory from one timestep to the other
        for var in ('sigs', 'WEIGHT_MF_CLOUD', 'CF_MF', 'rc_MF', 'ri_MF',
                    'HLC_HRC_MF', 'HLC_HCF_MF', 'HLI_HRI_MF', 'HLI_HCF_MF'):
            init_state[var] = numpy.zeros(init_state['P'].shape)

        # Initial value
        for var in ('CF', 'dt_rad_lw', 'dt_rad_sw'):
            init_state[var] = numpy.zeros(init_state['P'].shape)
        for var in ('lw_up', 'lw_dn', 'sw_up', 'sw_dn'):
            init_state[var] = numpy.zeros((init_state['P'].shape[0] + 1, ))
        for var in ('sfrv', 'swf', 'sfth', 'sshf', 'slhf'):
            if var not in init_state:
                init_state[var] = numpy.zeros((1, ))

        return init_state

    def forcing(self, state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """

        def get_interpolator(var, nc):
            """
            Get from cache or build the interpolator
            :param var: variable name
            :param nc: netcdf file
            :return: interpolator, netcdf file
            """
            if var in self.interpolators:
                interp = self.interpolators[var]
            else:
                if nc is None:
                    nc = netCDF4.Dataset(self.inputfile, 'r')
                input_times = nc['time'][...]
                if len(nc[var].shape) == 2:
                    if self.grid.kind in ('H', 'hybridH'):
                        input_coord = nc['zh_forc'][0, :]
                    elif self.grid.kind in ('P', 'hybridP'):
                        input_coord = nc['pa_forc'][0, :]
                    else:
                        raise Phyex1DError('Wrong grid kind')
                    interp = RegularGridInterpolator((input_times, input_coord), nc[var][...],
                                                     bounds_error=False, fill_value=None)
                else:
                    interp = RegularGridInterpolator((input_times, ), nc[var][...],
                                                     bounds_error=False, fill_value=None)
            return interp, nc

        time = timestep * timestep_number
        if self.grid.kind in ('H', 'hybridH'):
            output_coord = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        elif self.grid.kind in ('P', 'hybridP'):
            output_coord = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        else:
            raise Phyex1DError('Wrong grid kind')

        nc = None

        # Temperature advection and nudging, radiative tendency
        if 'Theta' in self.prognostic_variables:
            if self.case.adv_theta == 1:
                interp, nc = get_interpolator('tntheta_adv', nc)
                state['Theta'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                            output_coord))) * timestep
            if self.case.nudging_theta == 1:
                raise NotImplementedError('Nudging theta')
            if self.case.radiation == 'tend':
                interp, nc = get_interpolator('tntheta_rad', nc)
                state['Theta'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                            output_coord))) * timestep
        elif 'T' in self.prognostic_variables:
            if self.case.adv_ta == 1:
                interp, nc = get_interpolator('tnta_adv', nc)
                state['T'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                        output_coord))) * timestep
            if self.case.nudging_ta == 1:
                raise NotImplementedError('Nudging ta')
            if self.case.radiation == 'tend':
                interp, nc = get_interpolator('tnta_rad', nc)
                state['T'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                        output_coord))) * timestep

        # Hydrometeors advection and nudging
        if 'rv' in self.prognostic_variables:
            if self.case.adv_rv == 1:
                interp, nc = get_interpolator('tnrv_adv', nc)
                state['rv'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                         output_coord))) * timestep
            if self.case.nudging_rv == 1:
                raise NotImplementedError('Nudging rv')
        elif 'qv' in self.prognostic_variables:
            if self.case.adv_qv == 1:
                interp, nc = get_interpolator('tnqv_adv', nc)
                state['qv'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                         output_coord))) * timestep
            if self.case.nudging_qv == 1:
                raise NotImplementedError('Nudging qv')

        # Wind advection and nudging
        if self.case.adv_ua == 1:
            interp, nc = get_interpolator('tnua_adv', nc)
            state['u'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                    output_coord))) * timestep
        if self.case.adv_va == 1:
            interp, nc = get_interpolator('tnva_adv', nc)
            state['v'] += interp(numpy.column_stack(([time] * len(output_coord),
                                                    output_coord))) * timestep
        if self.case.nudging_ua == 1:
            raise NotImplementedError('Nudging u')
        if self.case.nudging_va == 1:
            raise NotImplementedError('Nudging v')
        if self.case.forc_wa == 1:
            # dX/dt = - w dX/dz
            print('Vertical velocity forcing must be implemented')
        if self.case.forc_geo == 1:
            #du/dt = +f * vgeo; dv/dt = -f * ugeo
            print('geostrophic forcing must be implemented')

        # Surface
        if 'Ts' in state:
            interp, nc = get_interpolator('ts_forc', nc)
            state['Ts'] = interp([time])[0]
        if 'Tskin' in state:
            interp, nc = get_interpolator('tskin', nc)
            state['Tskin'] = interp([time])[0]
        if 'Ps' in state:
            interp, nc = get_interpolator('ps_forc', nc)
            state['Ps'] = interp([time])[0]
        if self.case.surface_forcing_temp == 'surface_flux':
            interp, nc = get_interpolator('hfss', nc)
            state['sshf'] = interp([time])[0]
        if self.case.surface_forcing_moisture == 'surface_flux':
            interp, nc = get_interpolator('hfls', nc)
            state['slhf'] = interp([time])[0]
        if 'z0' in state:
            interp, nc = get_interpolator('z0', nc)
            state['z0'] = interp([time])[0]
        if 'z0h' in state:
            interp, nc = get_interpolator('z0h', nc)
            state['z0h'] = interp([time])[0]
        if 'z0q' in state:
            interp, nc = get_interpolator('z0q', nc)
            state['z0q'] = interp([time])[0]

        # Other fields
        interp, nc = get_interpolator('lat', nc)
        state['lat'] = interp([time])[0]
        interp, nc = get_interpolator('lon', nc)
        state['lon'] = interp([time])[0]

        if nc is not None:
            nc.close()

        return state


class PhysicsArome(PhysicsBase):
    """
    Implementation of a PHYEX timestep using the AROME way
    This class is not intended to be used directly
    """

    def phyex(self, state, timestep, timestep_number):
        """
        This method do the computational part of the time advance

        :param state:  dictionary holding all the variables.
        :param timestep: timestep (s)
        :param timestep_number: current time step
        :returns: a 'state' dictionary containing variable values after time integration
        """

        # Save initial state
        state0 = {k: v.copy() for (k, v) in state.items()}

        # Preparation: grid and other dimensions
        pressure = self.grid.get_pressure('MASS', state, self.prognostic_variables)
        z_mass = self.grid.get_altitude('MASS', state, self.prognostic_variables)
        z_flux = self.grid.get_altitude('FLUX', state, self.prognostic_variables)
        if self.grid.ascending:
            dzz = numpy.diff(z_flux)
            if dzz[-1] == numpy.inf:
                dzz[-1] = dzz[-2]
        else:
            dzz = -numpy.diff(z_flux)
            if dzz[0] == numpy.inf:
                dzz[0] = dzz[1]
        nijt = 1
        nkt = len(pressure)
        if self.full_phyex_namel['PHYEX']['CMICRO'] == 'ICE3':
            krr = 6
        elif self.full_phyex_namel['PHYEX']['CMICRO'] == 'ICE4':
            krr = 7
        else:
            raise Phyex1DError('Unknowm microphysics scheme')
        ksv = 0

        # Preparation: conversions
        exner = (pressure / 1.E5) ** (self.cst.Rd / self.cst.Cpd)
        if 'T' in self.prognostic_variables:
            theta = state['T'] / exner
            temperature = state['T']
        else:
            theta = state['Theta']
            temperature = exner * theta
        if 'qv' in self.prognostic_variables:
            qdm = 1.
            for var in ('qv', 'qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                qdm -= state[var]
            gas_constant = self.cst.Rd + state['qv'] * (self.cst.Rv - self.cst.Rd)
            for var in ('qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                gas_constant += - state[var] * self.cst.Rd
            rho = pressure / (gas_constant * temperature)
            rhodref = rho * qdm
            rv = state['qv'] / qdm
            rc = state['qc'] / qdm
            rr = state['qr'] / qdm
            ri = state['qi'] / qdm
            rs = state['qs'] / qdm
            rg = state['qg'] / qdm
            rh = state['qh'] / qdm
        else:
            qdm = 1.
            for var in ('rv', 'rc', 'rr', 'ri', 'rs', 'rg', 'rh'):
                qdm += state[var]
            qdm = 1. / qdm
            rv = state['rv']
            rc = state['rc']
            rr = state['rr']
            ri = state['ri']
            rs = state['rs']
            rg = state['rg']
            rh = state['rh']
            div = 1 + state['rv']
            for var in ('rc', 'rr', 'ri', 'rs', 'rg', 'rh'):
                if var in self.prognostic_variables:
                    div += state[var]
            gas_constant = (self.cst.Rd + state['rv'] * self.cst.Rv) / div
            rho = pressure / (gas_constant * temperature)
            rhodref = pressure / ((self.cst.Rd + rv * self.cst.Rv) * theta * exner)

        # Preparation: derived fields
        rhodj = dzz * rho

        # Preparation: tendencies
        us = state['u'] / timestep
        vs = state['v'] / timestep
        ws = state['w'] / timestep
        tkes = state['tke'] / timestep
        rvs = rv / timestep
        rcs = rc / timestep
        rrs = rr / timestep
        ris = ri / timestep
        rss = rs / timestep
        rgs = rg / timestep
        rhs = rh / timestep
        thetas = theta / timestep
        if 'qv' in self.prognostic_variables:
            dqv = numpy.zeros((nkt, ))
            dqc = numpy.zeros((nkt, ))
            dqr = numpy.zeros((nkt, ))
            dqi = numpy.zeros((nkt, ))
            dqs = numpy.zeros((nkt, ))
            dqg = numpy.zeros((nkt, ))
            dqh = numpy.zeros((nkt, ))
        if 'T' in self.prognostic_variables:
            dtemperature = numpy.zeros((nkt, ))

        # Preparation: misc fields
        sigqsat = numpy.ones((nijt, )) * self.full_phyex_namel['NAM_NEBn']['VSIGQSAT']
        mfconv = numpy.zeros((nkt, ))
        sv = numpy.zeros((ksv, nkt))
        svs = sv / timestep

        ##################################################################
        ##################################################################
        #                       ADJUSTMENT
        ##################################################################
        ##################################################################
        if self.full_phyex_namel['PHYEX']['CMICRO'] == 'NONE':
            pass
        elif self.full_phyex_namel['PHYEX']['CMICRO'] == 'ICE3':
            if 'qv' in self.prognostic_variables:
                rvsin = rvs.copy()
                rcsin = rcs.copy()
                risin = ris.copy()
            if 'T' in self.prognostic_variables:
                thsin = thetas.copy()
            x = numpy.newaxis
            result = self._pyphyex.PYICE_ADJUST(
                                 nijt, nkt, 1 if self.grid.ascending else -1, 0,
                                 krr, 'DEPO', timestep,
                                 sigqsat, rhodj[:, x],
                                 exner[:, x], rhodref[:, x], state['sigs'][:, x], False,
                                 mfconv[:, x], pressure[:, x], z_mass[:, x], exner[:, x],
                                 state['CF_MF'][:, x], state['rc_MF'][:, x],
                                 state['ri_MF'][:, x], state['WEIGHT_MF_CLOUD'][:, x], rv[:, x],
                                 rc[:, x], rvs[:, x], rcs[:, x],
                                 theta[:, x], thetas[:, x],
                                 True, rr[:, x], ri[:, x],
                                 ris[:, x], rs[:, x], rg[:, x], 0,
                                 PRH=rh if krr == 7 else MISSING,
                                 PHLC_HRC_MF=state['HLC_HRC_MF'][:, x],
                                 PHLC_HCF_MF=state['HLC_HCF_MF'][:, x],
                                 PHLI_HRI_MF=state['HLI_HRI_MF'][:, x],
                                 PHLI_HCF_MF=state['HLI_HCF_MF'][:, x])
            result = [array[:, 0] for array in result]
            (_, _, _, _, _, rvs, rcs, thetas, src, state['CF'], ris, _, _, _, _,
            hlc_hrc, hlc_hcf, hli_hri, hli_hcf) = result
            theta = thetas * timestep
            temperature = theta * exner
            rv = rvs * timestep
            rc = rcs * timestep
            ri = ris * timestep

            if 'qv' in self.prognostic_variables:
                qv = rv * qdm
                qc = rc * qdm
                qr = rr * qdm
                qi = ri * qdm
                qs = rs * qdm
                qg = rg * qdm
                qh = rh * qdm
                gas_constant = self.cst.Rd + state['qv'] * (self.cst.Rv - self.cst.Rd)
                for var in ('qc', 'qr', 'qi', 'qs', 'qg', 'qh'):
                    if var in self.prognostic_variables:
                        gas_constant += - state[var] * self.cst.Rd
                rho = pressure / (gas_constant * temperature)
                rhodref = rho * qdm
                dqv += (rvs - rvsin) * qdm
                dqc += (rcs - rcsin) * qdm
                dqi += (ris - risin) * qdm
            else:
                div = 1. + state['rv']
                for var in ('rc', 'rr', 'ri', 'rs', 'rg', 'rh'):
                    if var in self.prognostic_variables:
                        div += state[var]
                gas_constant = (self.cst.Rd + state['rv'] * self.cst.Rv) / div
                rho = pressure / (gas_constant * temperature)
                rhodref = pressure / ((self.cst.Rd + rv * self.cst.Rv) * theta * exner)

            if 'T' in self.prognostic_variables:
                dtemperature += (thetas - thsin) * exner

            # Update state to be able to recompute pressure and altitude
            if 'qv' in self.prognostic_variables:
                state['qv'] = state0['qv'] + dqv * timestep
                state['qc'] = state0['qc'] + dqc * timestep
                state['qr'] = state0['qr'] + dqr * timestep
                state['qi'] = state0['qi'] + dqi * timestep
                state['qs'] = state0['qs'] + dqs * timestep
                state['qg'] = state0['qg'] + dqg * timestep
                state['qh'] = state0['qh'] + dqh * timestep
            else:
                state['rv'] = rvs * timestep
                state['rc'] = rcs * timestep
                state['rr'] = rrs * timestep
                state['ri'] = ris * timestep
                state['rs'] = rss * timestep
                state['rg'] = rgs * timestep
                state['rh'] = rhs * timestep
            if 'T' in self.prognostic_variables:
                state['T'] = state0['T'] + dtemperature * timestep
            else:
                state['Theta'] = thetas * timestep
            pressure = self.grid.get_pressure('MASS', state, self.prognostic_variables)
            z_mass = self.grid.get_altitude('MASS', state, self.prognostic_variables)
            z_flux = self.grid.get_altitude('FLUX', state, self.prognostic_variables)
            if self.grid.ascending:
                dzz = numpy.diff(z_flux)
                if dzz[-1] == numpy.inf:
                    dzz[-1] = dzz[-2]
            else:
                dzz = -numpy.diff(z_flux)
                if dzz[0] == numpy.inf:
                    dzz[0] = dzz[1]
        else:
            raise Phyex1DError('Wrong CMICRO scheme choice for adjustment')

        ##################################################################
        ##################################################################
        #                       RADIATION
        ##################################################################
        ##################################################################
        if self.case.radiation == 'on':
            if self.full_phyex_namel['PHYEX']['RAD'] == 'NONE':
                pass
            elif self.full_phyex_namel['PHYEX']['RAD'] == 'ECRAD':
                order = -1 if self.grid.ascending else 1
                pressure_flux = self.grid.get_pressure('FLUX', state, self.prognostic_variables)
                temperature_flux = numpy.ndarray(pressure_flux .shape)
                temperature_flux[1:-1] = .5 * (temperature[1:] + temperature[:-1])
                tskin = state['Ts' if self.case.surface_type == 'ocean' else 'Tskin']
                if self.grid.ascending:
                    temperature_flux[0] = tskin
                    temperature_flux[-1] = temperature[-1]
                else:
                    temperature_flux[-1] = tskin
                    temperature_flux[0] = temperature[0]

                x = numpy.newaxis
                solar_irradiance = state.get('SolarIrradiance', 1366.)
                spectral_solar_cycle_multiplier = 0.
                if 'sza' in state:
                    cos_solar_zenith_angle = numpy.ones((nijt, )) * state['sza']
                else:
                    obs = ephem.Observer()
                    obs.lat = str(state['lat'])
                    obs.long = str(state['lon'])
                    obs.date = datetime.datetime.fromisoformat(self.case.start_date) + \
                               datetime.timedelta(seconds=timestep * timestep_number)
                    sun = ephem.Sun(obs)
                    sun.compute(obs)
                    cos_solar_zenith_angle = numpy.ones((nijt, )) * numpy.cos(numpy.pi / 2. - sun.alt)
                fractional_std = numpy.ones((nkt, )) * 1.  # could be computed by the cloud scheme
                q_liquid = rc * qdm
                # Simple distinction between land (10um) and ocean (13um) by Zhang and Rossow
                re_liquid = (10. if self.case.surface_type == 'ocean' else 13.)
                re_liquid = numpy.ones((nkt, )) * re_liquid * 1.E-6  # convert in m
                q_ice = ri * qdm
                # Liou and Ou
                temperature_c = numpy.minimum(temperature - self.cst.Tt, -0.1)
                re_ice = 326.3 + temperature_c * \
                         (12.42 + temperature_c * (0.197 + temperature_c * 0.0012))
                re_ice = numpy.minimum(numpy.maximum(re_ice, 40), 130) * 1.E-6
                iseed = numpy.ones((nijt, ), dtype=numpy.int64)
                overlap_param = numpy.ones((nkt - 1, ))  # 1 for max
                tskin = numpy.ones((nijt, )) * tskin
                sw_albedo = numpy.ones((1, )) * state.get('albedo', 1.)  # albedo diffuse
                sw_albedo_direct = sw_albedo.copy()  # albedo direct
                lw_emissivity =  numpy.ones((1, )) * state.get('emissivity', 1.)  # emissivity
                q = rv * qdm
                o3 = numpy.zeros((nkt, ))

                result = self._pyecrad.run(
                    1, len(pressure), pressure_flux[::order, x], temperature_flux[::order, x],
                    solar_irradiance, spectral_solar_cycle_multiplier, cos_solar_zenith_angle,
                    state['CF'][::order, x], fractional_std[::order, x], q_liquid[::order, x],
                    re_liquid[::order, x], q_ice[::order, x], re_ice[::order, x], iseed,
                    overlap_param[::order, x],
                    tskin, sw_albedo.shape[0], sw_albedo[:, x],
                    sw_albedo_direct[:, x], lw_emissivity.shape[0],
                    lw_emissivity[:, x], q[::order, x], o3[::order, x])
                result = [array[::order, 0] for array in result]
                state['lw_up'], state['lw_dn'], state['sw_up'], state['sw_dn'] = result
                cp = qdm * (self.cst.Cpd +
                            self.cst.Cpv * rv +
                            self.cst.Cl * (rc + rr) +
                            self.cst.Ci * (ri + rs + rg + rh))
                dt_rad_lw = -numpy.diff((state['lw_dn'] - state['lw_up'])[::order])[::order] / \
                            (rho * cp * dzz)
                dt_rad_sw = -numpy.diff((state['sw_dn'] - state['sw_up'])[::order])[::order] / \
                            (rho * cp * dzz)
                state['dt_rad_lw'] = dt_rad_lw
                state['dt_rad_sw'] = dt_rad_sw
                if 'T' in self.prognostic_variables:
                    dtemperature += dt_rad_lw + dt_rad_sw
                else:
                    thetas += (dt_rad_lw + dt_rad_sw) * exner
            else:
                raise Phyex1DError('Wrong RAD scheme choice')


        ##################################################################
        ##################################################################
        #                       SURFACE
        ##################################################################
        ##################################################################
        klevgrd = 0 if self.grid.ascending else -1
        if self.case.surface_forcing_temp in ('none', 'ts') or \
           self.case.surface_forcing_moisture in ('none', 'beta', 'mrsos') or \
           self.case.surface_forcing_wind in ('none', ):
            need_scheme = True
        else:
            need_scheme = False

        def ustar2fluxes(ustar, u, v):
            """
            Convert ustar into momentum fluxes
            :param ustar: ustar value
            :param u, v: wind components
            :return: w'u', w'v'
            """
            alpha = numpy.arctan2(v, u)
            return - ustar**2 * numpy.cos(alpha), - ustar**2 * numpy.sin(alpha)

        if 'Ts' in state:
            surface_temperature = state['Ts']
        else:
            if self.grid.ascending:
                surface_temperature = temperature[0]
            else:
                surface_temperature = temperature[-1]
        if surface_temperature > self.cst.Tt:
            latent_heat = self.cst.LvTt - (self.cst.Cpv - self.cst.Cl) * \
                          (surface_temperature - self.cst.Tt)
        else:
            latent_heat = self.cst.LsTt - (self.cst.Cpv - self.cst.Ci) * \
                          (surface_temperature - self.cst.Tt)

        # Surface schemes output must be: sshf (W m-2) and swf (kg m-2 s-1)
        sshf_scheme = None
        swf_scheme = None
        sfu_scheme = None
        sfv_scheme = None
        if self.full_phyex_namel['PHYEX']['SURFACE'] == 'NONE':
            sshf_scheme = 0.
            swf_scheme = 0.
            sfu_scheme = 0.
            sfv_scheme = 0.
        elif not need_scheme:
            pass
        elif self.full_phyex_namel['PHYEX']['SURFACE'] == 'WASP':
            if self.case.surface_forcing_temp == 'none':
                raise Phyex1DError('surface_forcing_temp == none not implemented by WASP')
            if self.case.surface_forcing_moisture in ('beta', 'mrsos'):
                raise Phyex1DError(
                    'surface_forcing_moisture == beta or mrsos not implemented by WASP')
            if self.case.surface_forcing_wind != 'none':
                raise Phyex1DError('surface_forcing_wind != none not implemented by WASP')
            windgrd = numpy.sqrt(state['u'][klevgrd]**2 + state['v'][klevgrd]**2)
            exner_surf =  (state['Ps'] / 1.E5) ** (self.cst.Rd / self.cst.Cpd)
            if 'qv' in self.prognostic_variables:
                qv_grd = state['rv'][klevgrd] * qdm[klevgrd]
            else:
                qv_grd = state['qv'][klevgrd]
            # TODO, filled precip in precipitation rate (kg/s/m2)
            precip = 0.

            wave_height = 0.
            wave_peak_period = 0.
            result = wasp.WASP_FLUX(
                state['T'][klevgrd], qv_grd, exner[klevgrd], rho[klevgrd], windgrd, z_mass[klevgrd],
                z_mass[klevgrd], state['Ts' if self.case.surface_type == 'ocean' else 'Tskin'],
                exner_surf, state['Ps'], precip, wave_height, wave_peak_period)
            sshf_scheme, swf_scheme, ustar = result
            sfu_scheme, sfv_scheme = ustar2fluxes(ustar, state['u'][klevgrd], state['v'][klevgrd])
        else:
            raise Phyex1DError('Wrong SURFACE scheme choice')

        if self.case.surface_forcing_temp == 'none':
            if sshf_scheme is None:
                raise Phyex1DError("Surface scheme didn't compute sshf")
        elif self.case.surface_forcing_temp == 'kinematic':
            raise NotImplementedError('surface_forcing_temp=kinematic')
        elif self.case.surface_forcing_temp == 'surface_flux':
            sshf = state['sshf']
        elif self.case.surface_forcing_temp == 'ts':
            sshf = sshf_scheme
        else:
            raise Phyex1DError('Wrong surface_forcing_temp option')

        if self.case.surface_forcing_moisture == 'none':
            if swf_scheme is None:
                raise Phyex1DError("Surface scheme didn't compute swf")
            swf = swf_scheme
        elif self.case.surface_forcing_moisture == 'kinematic':
            raise NotImplementedError('surface_forcing_moisture=kinematic')
        elif self.case.surface_forcing_moisture == 'surface_flux':
            # W m-2 --> kg m-2 s-1
            swf = state['slhf'] / latent_heat
        elif self.case.surface_forcing_moisture == 'beta':
            raise NotImplementedError('surface_forcing_moisture=beta')
        elif self.case.surface_forcing_moisture == 'mrsos':
            raise NotImplementedError('surface_forcing_moisture=mrsos')
        else:
            raise Phyex1DError('Wrong surface_forcing_moisture option')

        if self.case.surface_forcing_wind == 'none':
            sfu = sfu_scheme
            sfv = sfv_scheme
        elif self.case.surface_forcing_wind == 'z0':
            ustar = numpy.sqrt(state['u'][klevgrd]**2 + state['v'][klevgrd]**2) * \
                    self.cst.Karman / numpy.log(z_mass[klevgrd] / state['z0'])
            sfu, sfv = ustar2fluxes(ustar, state['u'][klevgrd], state['v'][klevgrd])
        elif self.case.surface_forcing_wind == 'ustar':
            sfu, sfv = ustar2fluxes(state['ustar'], state['u'][klevgrd], state['v'][klevgrd])
        else:
            raise Phyex1DError('Wrong surface_forcing_wind option')
        sfsv = numpy.zeros((ksv, ))

        # The turbulence scheme waits for w'r' and w'th'
        # for the water flux, we want w'r' (division by rhod) and not w'q' (division by rho)
        sfrv = swf / rhodref[0 if self.grid.ascending else -1]  # kg m-2 s-1 --> kg/kg m s-1
        cp = qdm * (self.cst.Cpd + self.cst.Cpv * rv + self.cst.Cl * (rc + rr) +
                    self.cst.Ci * (ri + rs + rg + rh))
        sfth = sshf / (self.cst.Cpd * rho[0 if self.grid.ascending else -1])  # W m-2 --> K m s-1

        state['sfrv'] = sfrv  # kg/kg m s-1 (w'r' mixing ratio)
        state['swf'] = swf  # kg m-2 s-1
        state['slhf'] = swf * latent_heat  # W m-2 using Lv or Ls depending on temperature °C sign
        state['sfth'] = sfth  # K m s-1 (w'th' theta)
        state['sshf'] = sshf  # W m-2

        ##################################################################
        ##################################################################
        #                       SHALLOW CONVECTION
        ##################################################################
        ##################################################################

        if self.full_phyex_namel['PHYEX']['CSCONV'] == 'NONE':
            flxzthvmf = flxzumf = flxzvmf = numpy.zeros((nkt, ))
        elif self.full_phyex_namel['PHYEX']['CSCONV'] == 'EDKF':
            # Updraft properties
            pthl_up = numpy.zeros((nkt, ))
            prt_up = numpy.zeros((nkt, ))
            prv_up = numpy.zeros((nkt, ))
            prc_up = numpy.zeros((nkt, ))
            pri_up = numpy.zeros((nkt, ))
            pu_up = numpy.zeros((nkt, ))
            pv_up = numpy.zeros((nkt, ))
            ptke_up = numpy.zeros((nkt, ))
            pthv_up = numpy.zeros((nkt, ))
            pw_up = numpy.zeros((nkt, ))
            pfrac_up = numpy.zeros((nkt, ))
            pemf = numpy.zeros((nkt, ))

            # Other arrays
            rm = numpy.array([rv, rc, rr, ri, rs, rg, rh])
            if self.grid.ascending:
                z_flux_trunc = z_flux[:-1]
            else:
                z_flux_trunc = z_flux[1:]

            x = numpy.newaxis
            result = self._pyphyex.PYSHALLOW_MF(
                         nijt, nkt, 1 if self.grid.ascending else -1,
                         0, krr, 2, 3, 0, False, 0, 0,
                         timestep, dzz[:, x], z_flux_trunc[:, x], rhodj[:, x],
                         rhodref[:, x], pressure[:, x], exner[:, x],
                         numpy.ones((nijt, )) * sfth, numpy.ones((nijt, )) * sfrv, theta[:, x],
                         rm[:krr, :, x], state['u'][:, x], state['v'][:, x], state['tke'][:, x],
                         sv[:, :, x], pthl_up[:, x], prt_up[:, x], prv_up[:, x], prc_up[:, x],
                         pri_up[:, x], pu_up[:, x], pv_up[:, x], ptke_up[:, x], pthv_up[:, x],
                         pw_up[:, x], pfrac_up[:, x], pemf[:, x],
                         self.dx, self.dy, PRSVS=svs[:, :, x], KBUDGETS=0)
            result = [array[..., 0] for array in result]
            (du_mf, dv_mf, dtke_mf, dthl_mf, drt_mf, dsv_mf, sigs_mf,
             state['rc_MF'], state['ri_MF'], state['CF_MF'], state['HLC_HRC_MF'],
             state['HLC_HCF_MF'], state['HLI_HRI_MF'], state['HLI_HCF_MF'],
             state['WEIGHT_MF_CLOUD'],
             flxzthvmf, flxzthmf, flxzrmf, flxzumf, flxzvmf, flxztkemf) = result[:21]
            us += du_mf
            vs += dv_mf
            tkes += dtke_mf
            svs += dsv_mf
            if 'Theta' in self.prognostic_variables:
                thetas += dthl_mf
            else:
                dtemperature += dthl_mf * exner
            if 'rv' in self.prognostic_variables:
                rvs += drt_mf
            else:
                dqv += drt_mf * qdm
        else:
            raise Phyex1DError('Wrong CSCONV scheme choice')

        ##################################################################
        ##################################################################
        #                       TURBULENCE
        ##################################################################
        ##################################################################
        if self.full_phyex_namel['PHYEX']['CTURB'] == 'NONE':
            pass
        elif self.full_phyex_namel['PHYEX']['CTURB'] == 'TKEL':
            hlbcx = hlbcy = numpy.array(['cycl', 'cycl'], dtype=('S', 4))
            kgradientsleo, kgradientsgog, khalo, ksplit = 0, 0, 1, 1
            ocloudmodiflm = False
            ksv_lgbeg, ksv_lgend = 0, 0
            ksv_lima_nr, ksv_lima_ns, ksv_lima_ng, ksv_lima_nh = 0, 0, 0, 0
            o2d, onomixlg, oflat, ocouples = False, False, False, False
            oblowsnow, oibm, oflyer, ocompute_src = False, False, True, True
            rsnow = 1.
            oocean, odeepoc, odiag_in_run = False, False, False
            hturblen_cl, helec = 'DELT', 'NONE'
            dxx = dyy = dzx = dzy = numpy.ndarray((nkt, ))
            dircosxw = dircosyw = dircoszw = cosslope = 1.
            sinslope = 0.
            hgradleo = numpy.ndarray((kgradientsleo, nkt))
            hgradgog = numpy.ndarray((kgradientsgog, nkt))
            lengthm, lengthh = numpy.zeros((nkt, )), numpy.zeros((nkt, ))
            mfmoist = numpy.zeros((nkt, ))
            cei = numpy.zeros((nkt, ))
            cei_min, cei_max = 0.001E-06, 0.01E-06
            coef_ampl_sat = 5.
            kbudgets = 12
            bl_depth, sbl_depth = 0., 0.
            rm = numpy.array([rv, rc, rr, ri, rs, rg, rh])
            rs = numpy.array([rvs, rcs, rrs, ris, rss, rgs, rhs])
            thvref = theta * (1 + rv * self.cst.Rv / self.cst.Rd) / (1 + rm.sum(axis=0))
            nvext_turb = 1
            krrl = 2
            krri = 3 if krr == 6 else 4
            def x(array, reverse=False):
                """Extend vertical dimension and add horizontal one"""
                if not reverse:
                    try:
                        len(array)
                        if len(array.shape) == 1:
                            new = numpy.ndarray((array.shape[0] + 2, ))
                            new[1:-1] = array
                            new[0] = new[1]
                            new[-1] = new[-2]
                            return new[:, numpy.newaxis]
                        if len(array.shape) == 2:
                            new = numpy.ndarray((array.shape[0], array.shape[1] + 2))
                            new[:, 1:-1] = array
                            new[:, 0] = new[:, 1]
                            new[:, -1] = new[:, -2]
                            return new[:, :, numpy.newaxis]
                    except TypeError:
                        return numpy.ones((nijt, )) * array
                    raise ValueError(type(array), str(array))
                else:
                    if len(array.shape) == 3:
                        return array[:, 1:-1, 0]
                    if len(array.shape) == 2:
                        return array[1:-1, 0]

            us = us * rhodj
            vs = vs * rhodj
            ws = ws * rhodj
            thetas = thetas * rhodj
            tkes = tkes * rhodj
            rs = rs * rhodj[numpy.newaxis, :]
            svs = svs * rhodj
            if self.grid.ascending:
                z_flux_trunc = z_flux[:-1]
            else:
                z_flux_trunc = z_flux[1:]

            result = self._pyphyex.PYTURB(
                    nijt, nkt + 2 * nvext_turb, 1 if self.grid.ascending else -1, nvext_turb,
                    krr, krrl, krri, hlbcx, hlbcy, kgradientsleo, kgradientsgog,
                    khalo, ksplit, ocloudmodiflm, ksv, ksv_lgbeg, ksv_lgend,
                    ksv_lima_nr, ksv_lima_ns, ksv_lima_ng, ksv_lima_nh,
                    o2d, onomixlg, oflat, ocouples, oblowsnow, oibm, oflyer,
                    ocompute_src, rsnow, oocean, odeepoc, odiag_in_run,
                    hturblen_cl, self.full_phyex_namel['PHYEX']['CMICRO'], helec, timestep, 999,
                    x(dxx), x(dyy), x(dzz), x(dzx), x(dzy), x(z_flux_trunc),
                    x(dircosxw), x(dircosyw), x(dircoszw), x(cosslope), x(sinslope),
                    x(rhodj), x(thvref), x(hgradleo), x(hgradgog), x(state['Zs']),
                    x(sfth), x(sfrv), sfsv[:, numpy.newaxis], x(sfu), x(sfv),
                    x(pressure), x(state['u']), x(state['v']), x(state['w']),
                    x(state['tke']), x(sv), x(src), x(lengthm), x(lengthh), x(mfmoist),
                    x(bl_depth), x(sbl_depth), x(cei), cei_min, cei_max, coef_ampl_sat,
                    x(theta), x(rm[:krr, ...]), x(us), x(vs), x(ws), x(thetas),
                    x(rs[:krr, ...]), x(svs), x(tkes),
                    x(flxzthvmf), x(flxzumf), x(flxzvmf),
                    kbudgets, missingOUT=['PEDR', 'PLEM', 'PDPMF', 'PTPMF',
                    'PTR', 'PDISS', 'PIBM_XMUT', 'PCURRENT_TKE_DISS'])

            result = [x(array, reverse=True) for array in result]
            (_, _, _, _, us, vs, ws, thetas, rs, svs, tkes, sigs_turb, _,
             _, _, _, _, _, _, _, _, dthetal_turb, drt_turb, _) = result

            us = us / rhodj
            vs = vs /rhodj
            ws = ws / rhodj
            thetas = thetas / rhodj
            tkes = tkes / rhodj
            dthetal_turb = dthetal_turb / rhodj
            drt_turb = drt_turb / rhodj
            rs = rs / rhodj[numpy.newaxis, :]
            svs = svs / rhodj

            if 'T' in self.prognostic_variables:
                dtemperature += dthetal_turb * exner
            if 'qv' in self.prognostic_variables:
                print('We must take into account tendencies on rc and ri. Here and in arome')
                dqv += drt_turb * qdm
            else:
                rvs = rs[0]
                rcs = rs[1]
                rrs = rs[2]
                ris = rs[3]
                rss = rs[4]
                rgs = rs[5]
                if krr == 7:
                    rhs = rs[6]
            state['sigs'] = numpy.sqrt(sigs_mf**2 + sigs_turb**2)
        else:
            raise Phyex1DError('Wrong CTURB scheme choice')

        ##################################################################
        ##################################################################
        #                       MICROPHYSICS
        ##################################################################
        ##################################################################
        #self._pyphyex.PYRAIN_ICE

        ##################################################################
        ##################################################################
        #                       NEW VALUES
        ##################################################################
        ##################################################################
        if 'qv' in self.prognostic_variables:
            state['qv'] = state0['qv'] + dqv * timestep
            state['qc'] = state0['qc'] + dqc * timestep
            state['qr'] = state0['qr'] + dqr * timestep
            state['qi'] = state0['qi'] + dqi * timestep
            state['qs'] = state0['qs'] + dqs * timestep
            state['qg'] = state0['qg'] + dqg * timestep
            state['qh'] = state0['qh'] + dqh * timestep
        else:
            state['rv'] = rvs * timestep
            state['rc'] = rcs * timestep
            state['rr'] = rrs * timestep
            state['ri'] = ris * timestep
            state['rs'] = rss * timestep
            state['rg'] = rgs * timestep
            state['rh'] = rhs * timestep
        if 'T' in self.prognostic_variables:
            state['T'] = state0['T'] + dtemperature * timestep
        else:
            state['Theta'] = thetas * timestep
        state['u'] = us * timestep
        state['v'] = vs * timestep
        state['tke'] = tkes * timestep
        return state


class PhysicsAromeTQ(PhysicsArome):
    """
    Implementation of a PHYEX timestep using the AROME way, with T and q as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None, pyecrad=None,
                 namel=None, dx=0, dy=0, attrs=None):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param pyecrad: path to the pyecrad.py file
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        :param attrs: dictionnary holding caes attributes to override
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['T', 'qv', 'qc', 'qi', 'qr', 'qs', 'qg', 'qh', 'u', 'v', 'w', 'tke'],
                         pyphyex, pyecrad, namel, dx, dy, attrs)


class PhysicsAromeThetaR(PhysicsArome):
    """
    Implementation of a PHYEX timestep using the AROME way, with Theta and r as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None, pyecrad=None,
                 namel=None, dx=0, dy=0, attrs=None):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param pyecrad: path to the pyecrad.py file
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        :param attrs: dictionnary holding caes attributes to override
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['Theta', 'rv', 'rc', 'ri', 'rr', 'rs', 'rg', 'rh', 'u', 'v', 'w', 'tke'],
                         pyphyex, pyecrad, namel, dx, dy, attrs)

class PhysicsForcingTQ(PhysicsBase):
    """
    Only the forcing with T and q as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None, pyecrad=None,
                 namel=None, dx=0, dy=0, attrs=None):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param pyecrad: path to the pyecrad.py file
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        :param attrs: dictionnary holding caes attributes to override
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['T', 'qv', 'qc', 'qi', 'qr', 'qs', 'qg', 'qh', 'u', 'v', 'w', 'tke'],
                         pyphyex, pyecrad, namel, dx, dy, attrs)


class PhysicsForcingThetaR(PhysicsBase):
    """
    Only the forcing with Theta and r as prognostic variables
    """

    def __init__(self, dt, method, name, tag, inputfile, grid, pyphyex=None, pyecrad=None,
                 namel=None, dx=0, dy=0, attrs=None):
        """
        :param dt: timestep (s)
        :param method: 'step-by-step' or 'one-step'
        :param name: full name of the execution
        :param tag: tag to identify the execution
        :param inputfile: netCDF file name describing the case
        :param grid: Grid object instance
        :param phyex: path to the pyphyex.py file generated by the PHYEX package
        :param pyecrad: path to the pyecrad.py file
        :param namel: namelist to use: as a file name or a dictionnary
        :param dx, dy: mesh size
        :param attrs: dictionnary holding caes attributes to override
        """
        super().__init__(dt, method, name, tag, inputfile, grid,
                         ['Theta', 'rv', 'rc', 'ri', 'rr', 'rs', 'rg', 'rh', 'u', 'v', 'w', 'tke'],
                         pyphyex, pyecrad, namel, dx, dy, attrs)
